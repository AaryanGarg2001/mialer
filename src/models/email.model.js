const mongoose = require('mongoose');

/**
 * @file Email Model
 * @module models/email
 * @requires mongoose
 */

/**
 * Email Schema Definition.
 * Represents an individual email message processed by the system.
 * Stores email content, metadata, processing results, and associated user.
 * @type {mongoose.Schema}
 */
const emailSchema = new mongoose.Schema({
  /** ID of the user this email belongs to. */
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User', // Reference to the User model
    required: true,
    index: true, // Index for faster queries by user
  },

  // ----- Gmail Identifiers -----
  /** Unique identifier for the email message from Gmail. */
  messageId: { type: String, required: true, unique: true, index: true },
  /** Identifier for the email thread from Gmail. */
  threadId: { type: String, required: true, index: true },

  // ----- Email Content -----
  /** Subject line of the email. */
  subject: { type: String, required: true, trim: true, maxlength: 500 },
  /** Sender's email address and optional name (e.g., "John Doe <john.doe@example.com>"). */
  sender: { type: String, required: true, trim: true, maxlength: 200, index: true },
  /** Array of recipient email addresses. */
  recipients: [{ type: String, trim: true, maxlength: 200 }],
  /** Plain text body of the email. */
  body: { type: String, required: true },
  /** HTML body of the email, if available. */
  htmlBody: { type: String, default: '' },
  /** Short snippet of the email content provided by Gmail. */
  snippet: { type: String, trim: true, maxlength: 500 },

  // ----- Gmail Metadata -----
  /** Array of Gmail labels applied to the email (e.g., 'INBOX', 'IMPORTANT'). */
  labels: [{ type: String }],
  /** Flag indicating if the email was marked as important by Gmail or user. */
  isImportant: { type: Boolean, default: false, index: true },
  /** Flag indicating if the email has been read. */
  isRead: { type: Boolean, default: false, index: true },
  /** Date and time when the email was originally received. */
  receivedAt: { type: Date, required: true, index: true },

  // ----- Processing Metadata -----
  /** Timestamp when this email was last processed by the system. */
  processedAt: { type: Date, default: Date.now },
  /** Score assigned by persona-based filtering (higher means more relevant to persona). */
  personalityScore: { type: Number, default: 0, min: 0, max: 20, index: true }, // Example range
  
  // ----- Attachments -----
  /** Array of attachment details for the email. */
  attachments: [{
    filename: String,
    mimeType: String,
    size: Number, // Size in bytes
    attachmentId: String, // ID for fetching attachment from Gmail
  }],

  // ----- AI Processing Results (Embedded Summary) -----
  /** Embedded summary generated by AI for this specific email. */
  summary: {
    /** The summarized content. */
    content: { type: String, trim: true },
    /** Array of actionable items extracted from the email. */
    actionItems: [String],
    /** AI-determined priority of the email. */
    priority: { type: String, enum: ['low', 'medium', 'high'], default: 'medium' },
    /** AI-determined category of the email. */
    category: { type: String, default: 'general', trim: true },
    /** AI-determined sentiment of the email content. */
    sentiment: { type: String, enum: ['positive', 'neutral', 'negative'], default: 'neutral' },
    /** Timestamp when this specific summary was generated. */
    generatedAt: Date,
  },

  // ----- User-applied Flags -----
  /** Flag indicating if the user has archived this email in our system. */
  isArchived: { type: Boolean, default: false, index: true },
  /** Flag indicating if the user has starred this email in our system. */
  isStarred: { type: Boolean, default: false, index: true },
  
}, {
  timestamps: true, // Automatically adds createdAt and updatedAt
  toJSON: { // Customize JSON output
    virtuals: true,
    transform: function(doc, ret) {
      delete ret.__v; // Remove Mongoose version key
      // delete ret.body; // Optionally remove large fields from default JSON output
      // delete ret.htmlBody;
      return ret;
    },
  },
  toObject: { virtuals: true }
});

// ----- INDEXES -----
// Compound indexes for common query patterns
emailSchema.index({ userId: 1, receivedAt: -1 }); // Sorting user's emails by date
emailSchema.index({ userId: 1, isRead: 1, receivedAt: -1 }); // Filtering unread emails
emailSchema.index({ userId: 1, isImportant: 1, receivedAt: -1 }); // Filtering important emails
emailSchema.index({ userId: 1, personalityScore: -1, receivedAt: -1 }); // For persona-based sorting
emailSchema.index({ userId: 1, 'summary.priority': 1, receivedAt: -1 }); // For sorting by summary priority

// Text search index for searching email content
emailSchema.index({
  subject: 'text',
  body: 'text', // Only include if text search on full body is needed and performant
  sender: 'text',
  'summary.content': 'text', // Include summary content in text search
}, {
  weights: { // Define relative importance of fields in text search
    subject: 10,
    sender: 5,
    'summary.content': 3,
    body: 1, // Lower weight for body due to size
  },
  name: 'email_text_search_index', // Naming the index
});

// ----- INSTANCE METHODS -----

/**
 * Marks the email as read.
 * @method markAsRead
 * @returns {Promise<Email>} The saved email document.
 */
emailSchema.methods.markAsRead = function() {
  this.isRead = true;
  return this.save();
};

/**
 * Marks the email as important.
 * @method markAsImportant
 * @returns {Promise<Email>} The saved email document.
 */
emailSchema.methods.markAsImportant = function() {
  this.isImportant = true;
  return this.save();
};

/**
 * Adds or updates the AI-generated summary for this email.
 * @method addSummary
 * @param {object} summaryData - Object containing summary details (content, actionItems, priority, etc.).
 * @returns {Promise<Email>} The saved email document.
 */
emailSchema.methods.addSummary = function(summaryData) {
  this.summary = {
    ...summaryData,
    generatedAt: new Date(), // Timestamp the summary generation
  };
  return this.save();
};

// ----- STATIC METHODS -----

/**
 * Finds emails for a given user, with options for filtering and pagination.
 * @static findByUser
 * @param {mongoose.Types.ObjectId} userId - The ID of the user.
 * @param {object} [options={}] - Query options.
 * @param {boolean} [options.unreadOnly=false] - Filter by unread emails.
 * @param {boolean} [options.importantOnly=false] - Filter by important emails.
 * @param {Date} [options.after] - Filter emails received after this date.
 * @param {Date} [options.before] - Filter emails received before this date.
 * @param {number} [options.limit=50] - Maximum number of emails to return.
 * @returns {Promise<Array<Email>>} A promise that resolves to an array of email documents.
 */
emailSchema.statics.findByUser = function(userId, options = {}) {
  const query = { userId };
  
  if (options.unreadOnly) query.isRead = false;
  if (options.importantOnly) query.isImportant = true;
  if (options.isArchived !== undefined) query.isArchived = options.isArchived;
  
  const dateQuery = {};
  if (options.after) dateQuery.$gte = new Date(options.after);
  if (options.before) dateQuery.$lte = new Date(options.before);
  if (Object.keys(dateQuery).length > 0) query.receivedAt = dateQuery;
  
  return this.find(query)
    .sort({ receivedAt: -1 }) // Default sort by most recent
    .limit(options.limit || 50);
};

/**
 * Finds all emails belonging to a specific thread for a user.
 * @static findByThread
 * @param {mongoose.Types.ObjectId} userId - The ID of the user.
 * @param {string} threadId - The Gmail thread ID.
 * @returns {Promise<Array<Email>>} A promise that resolves to an array of email documents in the thread, sorted by received date.
 */
emailSchema.statics.findByThread = function(userId, threadId) {
  return this.find({ userId, threadId }).sort({ receivedAt: 1 });
};

/**
 * Searches emails for a user based on a search term using the text index.
 * @static searchEmails
 * @param {mongoose.Types.ObjectId} userId - The ID of the user.
 * @param {string} searchTerm - The term to search for.
 * @param {number} [limit=20] - Maximum number of results to return.
 * @returns {Promise<Array<Email>>} A promise that resolves to an array of matching email documents, sorted by text search score.
 */
emailSchema.statics.searchEmails = function(userId, searchTerm, limit = 20) {
  return this.find(
    { userId, $text: { $search: searchTerm } },
    { score: { $meta: 'textScore' } } // Project the text search score
  )
  .sort({ score: { $meta: 'textScore' } }) // Sort by relevance
  .limit(limit);
};

/**
 * Retrieves aggregated email statistics for a user over a specified number of days.
 * @static getEmailStats
 * @param {mongoose.Types.ObjectId} userId - The ID of the user.
 * @param {number} [days=7] - The number of past days to include in the stats.
 * @returns {Promise<Array<object>>} Aggregated statistics (total, unread, important, avgScore per day).
 */
emailSchema.statics.getEmailStats = function(userId, days = 7) {
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - days);
  startDate.setHours(0, 0, 0, 0); // Start from the beginning of the day
  
  return this.aggregate([
    {
      $match: { // Filter emails for the user and date range
        userId: new mongoose.Types.ObjectId(userId), // Ensure userId is ObjectId
        receivedAt: { $gte: startDate }
      }
    },
    {
      $group: { // Group by date
        _id: {
          year: { $year: '$receivedAt' },
          month: { $month: '$receivedAt' },
          day: { $dayOfMonth: '$receivedAt' }
        },
        totalEmails: { $sum: 1 },
        unreadEmails: { $sum: { $cond: [{ $eq: ['$isRead', false] }, 1, 0] } },
        importantEmails: { $sum: { $cond: [{ $eq: ['$isImportant', true] }, 1, 0] } },
        avgPersonalityScore: { $avg: '$personalityScore' }
      }
    },
    {
      $project: { // Reshape the output for better readability
        date: {
          $dateFromParts: {
            year: '$_id.year',
            month: '$_id.month',
            day: '$_id.day'
          }
        },
        totalEmails: 1,
        unreadEmails: 1,
        importantEmails: 1,
        avgPersonalityScore: 1,
        _id: 0 // Exclude the default _id group field
      }
    },
    {
      $sort: { date: 1 } // Sort by date ascending
    }
  ]);
};

// ----- MIDDLEWARE (HOOKS) -----

/**
 * Pre-save middleware for the Email schema.
 * Truncates `body` and `htmlBody` fields if they exceed maximum length.
 * @listens Mongoose#save:pre
 * @param {import('express').NextFunction} next - Callback to continue the save operation.
 */
emailSchema.pre('save', function(next) {
  const MAX_BODY_LENGTH = 50000; // Max length for plain text body
  const MAX_HTML_BODY_LENGTH = 100000; // Max length for HTML body

  if (this.body && this.body.length > MAX_BODY_LENGTH) {
    logger.warn(`Truncating body for email ${this.messageId} due to excessive length. Original: ${this.body.length}, Max: ${MAX_BODY_LENGTH}`);
    this.body = this.body.substring(0, MAX_BODY_LENGTH) + '... [truncated]';
  }
  
  if (this.htmlBody && this.htmlBody.length > MAX_HTML_BODY_LENGTH) {
    logger.warn(`Truncating htmlBody for email ${this.messageId} due to excessive length. Original: ${this.htmlBody.length}, Max: ${MAX_HTML_BODY_LENGTH}`);
    this.htmlBody = this.htmlBody.substring(0, MAX_HTML_BODY_LENGTH) + '... [truncated]';
  }
  
  next();
});

const Email = mongoose.model('Email', emailSchema);

module.exports = Email;